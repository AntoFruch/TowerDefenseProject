1ï¸âƒ£ SystÃ¨me basÃ© sur le numÃ©ro de vague

La solution la plus simple et la plus courante.

Principe

Tu as une variable waveIndex

Plus waveIndex est grand :

plus il y a de monstres

plus les monstres sont forts

plus les types rares apparaissent

Exemple de logique

Vague 1â€“3 : monstres faibles uniquement

Vague 4â€“6 : ajout de monstres moyens

Vague 7+ : monstres forts + Ã©lites

void LoadNextWave()
{
    currentWave.Clear();
    waveIndex++;

    int monsterCount = 3 + waveIndex * 2;

    for (int i = 0; i < monsterCount; i++)
    {
        if (waveIndex < 3)
            currentWave.Add(MonsterType.GroBleu);
        else if (waveIndex < 6)
            currentWave.Add(Random.value < 0.7f ? MonsterType.GroJaune : MonsterType.GroBleu);
        else
            currentWave.Add(RandomMonster());
    }
}

2ï¸âƒ£ SystÃ¨me de budget de difficultÃ©

TrÃ¨s utilisÃ© dans les jeux pro (Left 4 Dead, Risk of Rain).

Principe

Chaque monstre a un coÃ»t

La vague a un budget

Tu dÃ©penses le budget pour remplir la vague

Dictionary<MonsterType, int> monsterCost = new()
{
    { MonsterType.GroBleu, 1 },
    { MonsterType.GroJaune, 2 },
    { MonsterType.Shell, 4 }
};

void LoadNextWave()
{
    currentWave.Clear();
    waveIndex++;

    int budget = 5 + waveIndex * 3;

    while (budget > 0)
    {
        MonsterType m = GetAffordableMonster(budget);
        currentWave.Add(m);
        budget -= monsterCost[m];
    }
}


âœ… Avantages :

TrÃ¨s Ã©quilibrable

Facile Ã  scaler

Permet des vagues variÃ©es

3ï¸âƒ£ DÃ©blocage progressif des monstres
Principe

Certains monstres sont bloquÃ©s au dÃ©but

Ils apparaissent Ã  partir dâ€™une vague donnÃ©e

MonsterType GetMonsterForWave()
{
    if (waveIndex < 3)
        return MonsterType.GroBleu;
    if (waveIndex < 6)
        return Random.value < 0.5f ? MonsterType.GroJaune : MonsterType.GroBleu;

    return Random.value < 0.3f ? MonsterType.Shell : MonsterType.GroJaune;
}

4ï¸âƒ£ DifficultÃ© par stats au lieu du nombre

MÃªme nombre de monstres, mais plus forts.

Exemple

+10% HP par vague

+5% dÃ©gÃ¢ts par vague

+2% vitesse par vague

float hpMultiplier = 1f + waveIndex * 0.1f;
float damageMultiplier = 1f + waveIndex * 0.05f;


ğŸ‘‰ TrÃ¨s efficace si tu veux garder des vagues lisibles.

5ï¸âƒ£ Variantes de vagues (rythme de jeu)

Pour Ã©viter la monotonie :

Type de vague	Description
Swarm	Beaucoup de petits
Elite	Peu mais trÃ¨s forts
Mixte	Un peu de tout
Boss	1 trÃ¨s gros ennemi
if (waveIndex % 5 == 0)
    SpawnBossWave();
else if (waveIndex % 3 == 0)
    SpawnSwarmWave();
else
    SpawnNormalWave();

6ï¸âƒ£ Influence du joueur (adaptive difficulty)

Si le joueur roule sur le jeu :

vagues plus dures

moins de soins

ennemis plus agressifs

Si le joueur galÃ¨re :

vagues plus courtes

ennemis plus faibles

if (playerHealth < 30)
    difficultyModifier = 0.8f;
else
    difficultyModifier = 1.2f;

7ï¸âƒ£ DonnÃ©es externes (recommandÃ©)

DÃ©finir les vagues dans un ScriptableObject ou JSON.

[System.Serializable]
public class WaveData
{
    public List<MonsterType> monsters;
}


Avantage :

Aucun code Ã  modifier

Ã‰quilibrage rapide

ğŸ”¥ Recommandation finale

ğŸ‘‰ Budget de difficultÃ© + dÃ©blocage progressif
Câ€™est le combo le plus flexible et scalable.

Si tu veux, dis-moi :

quel type de jeu câ€™est

combien de monstres existent

si câ€™est tour par tour ou temps rÃ©el

et je te ferai une implÃ©mentation complÃ¨te prÃªte Ã  lâ€™emploi ğŸ‘Œ